เขียน simulation program สำหรับการทำ fuzzy logic (approximate reasoning) จะใช้ระบบแบบ Mamdani หรือ Takagi & Sugeno แบบใดก็ได้ ให้นักศึกษาแต่ละคนเลือกทำในระบบควบคุมที่ต่างกัน รายงานจะต้องประกอบไปด้วย

       1. ลักษณะการทำงานของระบบ รวมถึง rules ที่ใช้

       2. simulation ของระบบ ผลการทดลอง และวิเคราะห์

       3 โปรแกรม

ตัวอย่างของระบบควบคุมเช่น fuzzy washing machine, fuzzy air conditioner การเดินของหุ่นยนต์ ฯลฯ

 

หมายเหตุ ควรจะเขียนรายงานให้อยู่ในรูปแบบรายงานที่ดี รวมถึงการวิเคราะห์ที่ดีด้วย

 
โค้ดข้างต้นเป็นระบบ Mamdani Fuzzy Inference System (FIS) ที่ออกแบบมาเพื่อช่วยในการตัดสินใจในสถานการณ์ที่เกี่ยวข้องกับสามปัจจัยหลัก ได้แก่:

Occupancy Factor (ปัจจัยการใช้งาน)
Average Distance (ระยะห่างเฉลี่ย)
Traffic Intensity (ความเข้มข้นของการจราจร)
โดยระบบจะนำค่าปัจจัยเหล่านี้มาใช้ประเมินตามกฎที่กำหนดไว้ล่วงหน้า แล้วคำนวณผลลัพธ์เป็นค่าเดียวที่แสดงถึงระดับการตัดสินใจขั้นสุดท้าย

วัตถุประสงค์ของโค้ด
ระบบนี้อาจใช้เพื่อช่วยในการตัดสินใจในสถานการณ์ที่เกี่ยวกับการจัดการหรือควบคุมการจราจรในพื้นที่ เช่น การควบคุมความหนาแน่นของยานพาหนะบนถนน การประเมินความแออัดของการจราจรในสถานที่สาธารณะ หรือในสภาพแวดล้อมที่มีการใช้งานพื้นที่สูง

ตัวอย่างการใช้งาน
ระบบนี้อาจใช้ในหลายสถานการณ์ เช่น:

การควบคุมสัญญาณไฟจราจร: ใช้เพื่อกำหนดระยะเวลาไฟเขียวหรือไฟแดงตามระดับความหนาแน่นของยานพาหนะ การเว้นระยะห่าง และความเข้มข้นของการจราจร
การจัดการพื้นที่จอดรถ: สามารถใช้เพื่อประเมินว่าที่จอดรถควรมีการควบคุมการเข้าออกอย่างไร ขึ้นอยู่กับการใช้งานพื้นที่ ระยะห่างระหว่างรถ และระดับการจราจรโดยรอบ
ระบบวางแผนการเดินทางในเมือง: ใช้เพื่อวิเคราะห์ความหนาแน่นของการจราจรบนถนนในเมือง และช่วยในการวางแผนเส้นทางเพื่อบรรเทาการจราจรที่แออัด
หลักการทำงานของระบบ
โดยระบบจะใช้เทคนิค fuzzy logic เพื่อทำให้สามารถทำงานได้ในสถานการณ์ที่ข้อมูลมีความคลุมเครือ หรือมีความไม่แน่นอนสูง (เช่น การใช้งานพื้นที่สูงและการจราจรที่หนาแน่น) ซึ่งทำให้การตัดสินใจมีความยืดหยุ่นและเป็นไปตามสถานการณ์

โค้ดข้างต้นเป็นส่วนหนึ่งของการสร้างฟังก์ชันการเป็นสมาชิก (membership function) สำหรับการประมวลผลด้วย Mamdani Fuzzy Inference System (FIS) โดยใช้รูปแบบกราฟต่างๆ และหาค่าเซ็นทรอยด์ (centroid) ของกราฟรวมเมื่อได้ผลลัพธ์ที่รวมกันจากกฎต่างๆ แล้ว

อธิบายการทำงานของฟังก์ชันแต่ละส่วน
1. ฟังก์ชัน trimf และ trapmf
ฟังก์ชันเหล่านี้ใช้สำหรับสร้าง ฟังก์ชันการเป็นสมาชิกแบบสามเหลี่ยม (triangular) (trimf) และ แบบสี่เหลี่ยมคางหมู (trapezoidal) (trapmf) ซึ่งใช้ในการหาค่าการเป็นสมาชิก (membership value) ของข้อมูลอินพุต

trimf(x, points):

รับค่าพารามิเตอร์ x (อินพุต) และ points (จุด 3 จุดที่กำหนดขอบเขตของกราฟสามเหลี่ยม)
คำนวณค่าการเป็นสมาชิกโดยแบ่งเป็น 2 ช่วง ได้แก่ช่วง pointA ถึง pointB และ pointB ถึง pointC
ใช้ฟังก์ชัน getSlope และ getYIntercept เพื่อคำนวณความชันและจุดตัดแกน y ในแต่ละช่วง แล้วนำไปคำนวณค่าการเป็นสมาชิก
trapmf(x, points):

รับค่าพารามิเตอร์ x (อินพุต) และ points (จุด 4 จุดที่กำหนดขอบเขตของกราฟสี่เหลี่ยมคางหมู)
กราฟนี้แบ่งเป็น 3 ช่วง ได้แก่ pointA ถึง pointB, pointB ถึง pointC และ pointC ถึง pointD
คำนวณค่าการเป็นสมาชิกในแต่ละช่วง โดยใช้ getSlope และ getYIntercept เช่นเดียวกับ trimf
2. ฟังก์ชัน getSlope และ getYIntercept
getSlope(x1, y1, x2, y2):

คำนวณความชันของเส้นเชื่อมระหว่างจุดสองจุด (x1, y1) และ (x2, y2) โดยใช้สูตรความชัน
มีการจัดการกรณี zero division error เพื่อหลีกเลี่ยงการหารด้วยศูนย์
getYIntercept(x1, y1, x2, y2):

คำนวณจุดตัดแกน y (y-intercept) สำหรับเส้นเชื่อมระหว่างจุด (x1, y1) และ (x2, y2) โดยใช้ความชันที่ได้จาก getSlope
3. ฟังก์ชัน getTrimfPlots และ getTrapmfPlots
ฟังก์ชันเหล่านี้สร้าง พล็อตของฟังก์ชันการเป็นสมาชิก สำหรับกราฟสามเหลี่ยม (trimf) และสี่เหลี่ยมคางหมู (trapmf) ตามช่วงที่กำหนด (เช่นจาก start ถึง end) และจุดที่กำหนดในพารามิเตอร์ points

getTrimfPlots(start, end, points):

กำหนดพล็อตสำหรับกราฟสามเหลี่ยมระหว่าง pointA, pointB, และ pointC
กราฟสามเหลี่ยมจะเริ่มจาก pointA ขึ้นไปถึงค่ามากสุดที่ pointB และลงมาถึง pointC
getTrapmfPlots(start, end, points, shoulder=None):

สร้างพล็อตของฟังก์ชันสี่เหลี่ยมคางหมูระหว่าง pointA, pointB, pointC, และ pointD
ถ้ามีค่า shoulder กำหนดเป็น "left" หรือ "right" จะสร้างกราฟที่เป็นไหล่ซ้ายหรือไหล่ขวาของกราฟสี่เหลี่ยมคางหมู (constant 1 ด้านซ้ายหรือขวา)
พล็อตนี้จะมีค่า membership = 1 ระหว่าง pointB ถึง pointC และลดลงในช่วง pointC ถึง pointD
4. ฟังก์ชัน getCentroid
คำนวณ ค่าเซ็นทรอยด์ (จุดศูนย์กลางมวล) ของผลรวม membership function จากพล็อตทั้งหมด โดยใช้วิธีถ่วงน้ำหนัก (weighted average method)
centroidNum คำนวณเป็นผลรวมของตำแหน่ง x คูณกับค่าการเป็นสมาชิก aggregatedPlots[i] แต่ละจุด
centroidDenum เป็นผลรวมของค่าการเป็นสมาชิกทั้งหมด
ผลลัพธ์ของ getCentroid จะเป็นตำแหน่งจุดศูนย์กลางของกราฟ ซึ่งสามารถนำไปใช้เป็นค่าผลลัพธ์ของระบบ fuzzy ได้
บทสรุป
โค้ดนี้สร้างฟังก์ชันการเป็นสมาชิกแบบสามเหลี่ยมและสี่เหลี่ยมคางหมู ใช้สำหรับคำนวณค่าการเป็นสมาชิก (fuzzification) จากข้อมูลอินพุต แล้วรวมค่าการเป็นสมาชิกเพื่อหาค่าเซ็นทรอยด์ (defuzzification) เพื่อใช้เป็นค่าผลลัพธ์ที่สมเหตุสมผล

จากโค้ดนี้ ผลลัพธ์ที่ควรได้รับและรูปแบบของกราฟจะเป็นดังนี้:

ค่าความแออัดทางจราจร:

โปรแกรมจะพิมพ์ค่าที่เป็นตัวเลขออกมา โดยเป็นค่าเซ็นทรอยด์ที่ได้จากการรวมกฎทั้งหมด (aggregation) และแบ่งด้วย 100 เพื่อให้อยู่ในช่วงที่เหมาะสม
ค่าเซ็นทรอยด์นี้แสดงถึงระดับของความแออัด โดยค่าที่ได้จะอยู่ในช่วงที่กำหนด เช่น ระดับ 0-1, 0-10 หรือเปอร์เซ็นต์ 0-100 ตามการตั้งค่าใน outputMfs
กราฟของฟังก์ชันการเป็นสมาชิก:

ฟังก์ชัน getVSPlots(), getSPlots(), getRSPlots(), getMPlots(), getRLPlots(), getLPlots(), getVLPlots() จะสร้างกราฟฟังก์ชันการเป็นสมาชิกสำหรับแต่ละระดับของความแออัด เช่น Very Small (VS), Small (S), Medium (M), Large (L) เป็นต้น
กราฟเหล่านี้จะเป็นกราฟที่แสดงฟังก์ชันการเป็นสมาชิกของแต่ละช่วงความแออัดทางจราจร โดยมีลักษณะเป็นฟังก์ชัน สามเหลี่ยม (triangular membership function) และ สี่เหลี่ยมคางหมู (trapezoidal membership function) ที่แสดงช่วงของค่าความแออัดแต่ละระดับ เช่น:
VS (Very Small): ช่วงค่าเล็กมาก 0-20
M (Medium): ช่วงค่า 40-60
VL (Very Large): ช่วงค่าที่สูงสุด เช่น 80-100
กราฟการรวมผลลัพธ์ (Aggregated Output Plot):

กราฟนี้เป็นการรวมการประเมินจากกฎทั้งหมดที่ผ่าน fisAggregation เพื่อแสดงค่าการเป็นสมาชิกของความแออัดที่ได้จากอินพุต โดยแสดงออกมาเป็นกราฟการเป็นสมาชิกแบบ fuzzy ที่มีช่วงการเป็นสมาชิกผสมผสานจากหลายระดับ เช่น ความแออัดต่ำถึงสูง
การแสดงผลนี้จะช่วยให้เห็นการเป็นสมาชิกโดยรวมที่มาจากการประมวลผลกฎต่าง ๆ รวมกัน
ค่าเซ็นทรอยด์ (Centroid):

โปรแกรมจะคำนวณและแสดงค่าเซ็นทรอยด์ ซึ่งเป็นค่าเฉลี่ยถ่วงน้ำหนักของกราฟการรวมผลลัพธ์ โดยเป็นตัวแทนของระดับความแออัดที่คาดการณ์
ในโปรแกรมตรวจสอบความหนาแน่นทางจราจรนี้ มีการใช้กฎ (rules) จำนวน 27 กฎ ซึ่งแต่ละกฎถูกออกแบบให้ใช้ค่าจากปัจจัย 3 อย่าง คือ occupancyFactor (ปัจจัยความหนาแน่น), averageDistance (ระยะทางเฉลี่ยระหว่างรถ) และ trafficIntensity (ปัจจัยความเข้มข้นของจราจร) โดยใช้ค่าของฟังก์ชันการเป็นสมาชิก (membership functions) มาประกอบกันเพื่อตัดสินค่าความหนาแน่นของจราจร ผลลัพธ์ที่ได้จากกฎแต่ละข้อจะเป็นค่าความหนาแน่นที่แบ่งออกเป็น 7 ช่วง ได้แก่ VS (Very Small), S (Small), RS (Rather Small), M (Medium), RL (Rather Large), L (Large), และ VL (Very Large) ซึ่งจัดเก็บไว้ในคอลัมน์ที่สอดคล้องกัน

กฎที่ใช้ในระบบมีโครงสร้างดังนี้:

กฎการใช้งาน: แต่ละกฎถูกกำหนดเพื่อระบุระดับความหนาแน่นของจราจร โดยอาศัยการคำนวณค่าต่ำสุด (min) ของการเป็นสมาชิกที่ได้รับจากปัจจัย occupancyFactor, averageDistance, และ trafficIntensity แล้วนำไปเก็บในคอลัมน์ที่ตรงกับความหนาแน่นที่คาดว่าจะได้

ตัวแปรการเป็นสมาชิกของข้อมูลนำเข้า:

occupancyFactor: แบ่งเป็น ml (ต่ำ), mm (ปานกลาง), และ mh (สูง)
averageDistance: แบ่งเป็น ss (สั้น), sm (ปานกลาง), และ sl (ยาว)
trafficIntensity: แบ่งเป็น pl (ต่ำ), pm (ปานกลาง), และ ph (สูง)
การแม็ปกฎกับความหนาแน่นของจราจร:

เมื่อ occupancyFactor และ trafficIntensity ต่ำ (pl): ความหนาแน่นของจราจรจะอยู่ในช่วง VS ถึง S
เมื่อ trafficIntensity ปานกลาง (pm): ความหนาแน่นจะเพิ่มขึ้น โดยอยู่ระหว่าง VS ถึง RS
เมื่อ trafficIntensity สูง (ph): ความหนาแน่นจะมีค่าในช่วงตั้งแต่ M ถึง VL ขึ้นอยู่กับปัจจัย occupancyFactor และ averageDistance
ตัวอย่างของการกำหนดกฎ:

rules[0][0] = min(min(ml, ss), pl): กรณีที่ occupancyFactor ต่ำ (ml), averageDistance สั้น (ss), และ trafficIntensity ต่ำ (pl) จราจรถูกกำหนดให้มีความหนาแน่น VS
rules[18][6] = min(min(ml, ss), ph): กรณีที่ occupancyFactor ต่ำ (ml), averageDistance สั้น (ss), และ trafficIntensity สูง (ph) ความหนาแน่นจะอยู่ที่ VL (Very Large)
โครงสร้างนี้ช่วยให้ระบบสามารถประเมินความหนาแน่นของจราจรตามสถานการณ์ที่แตกต่างกันได้

เพื่อให้ระบบสามารถประเมินความหนาแน่นของจราจรได้ เราสามารถใส่ค่าตัวอย่างสำหรับปัจจัยทั้งสามดังนี้:

ตัวอย่างที่ 1 (การจราจรเบาบาง):

occupancyFactor = 0.2 (หรือ 20%): มีความหนาแน่นต่ำ
averageDistance = 0.8 (หรือ 80%): ระยะทางเฉลี่ยระหว่างรถค่อนข้างห่าง
trafficIntensity = 0.1 (หรือ 10%): ความเข้มข้นการจราจรต่ำ
ในกรณีนี้ ระบบน่าจะให้ค่าความหนาแน่นของจราจรในช่วงต่ำ (VS หรือ S)

ตัวอย่างที่ 2 (การจราจรปานกลาง):

occupancyFactor = 0.5 (หรือ 50%): มีความหนาแน่นปานกลาง
averageDistance = 0.5 (หรือ 50%): ระยะทางเฉลี่ยปานกลางระหว่างรถ
trafficIntensity = 0.5 (หรือ 50%): ความเข้มข้นของจราจรปานกลาง
ค่าผลลัพธ์จากระบบอาจอยู่ในช่วงปานกลาง (M) เนื่องจากทุกปัจจัยอยู่ในระดับปานกลาง

ตัวอย่างที่ 3 (การจราจรหนาแน่น):

occupancyFactor = 0.9 (หรือ 90%): ความหนาแน่นของรถค่อนข้างสูง
averageDistance = 0.2 (หรือ 20%): ระยะห่างระหว่างรถค่อนข้างสั้น
trafficIntensity = 0.8 (หรือ 80%): ความเข้มข้นของการจราจรสูง
ค่าผลลัพธ์จากระบบน่าจะเป็นระดับ L หรือ VL ซึ่งหมายถึงความหนาแน่นของจราจรสูง
